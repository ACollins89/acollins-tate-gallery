<!DOCTYPE html>
<meta charset="utf-8">
<title>Artists of the Tate</title>
<link href='https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300,700' rel='stylesheet' type='text/css'>

<style>
@import url(../style.css?aea6f0a);
.children:hover rect.parent {opacity: 0;}
.children rect.parent, .grandparent rect {cursor: pointer;}
.children:hover rect.child {opacity: 1; stroke-width: 1px;}
.legend rect {stroke-width: 0px;}
.grandparent text {font-weight: bold;}
.grandparent:hover rect {fill: #5A5050;}
.children rect.child {opacity: 0;}
.children rect.parent {}
.legend text {text-anchor: middle; pointer-events: auto; font-size: 15px; font-family: 'Open Sans Condensed', Helvetica, sans-serif; fill: black;}
#chart {width: 960px; height: 500px;}
text {pointer-events: none;}
rect {stroke: #fff; stroke-width: 5px;}
rect.parent, .grandparent rect {stroke-width: 2px;}
p {color:#5A5050; font-family: 'Open Sans Condensed', Helvetica, sans-serif; font-size: 90%;}
p2 {color:#5A5050; font-family: 'Open Sans Condensed', Helvetica, sans-serif; font-size: 75%;}
h1 {color:#5A5050; font-family: 'Open Sans Condensed', Helvetica, sans-serif; font-size: 100%;}
</style>

<h1>The Artists of the Tate: When They Lived and Where They Came From</h1>
<p>Click on cells in the first layer to move to the next. Click on the title cell to return to the first layer. Larger boxes equate to more artists, while darker boxes indicate a greater percentage of female artists.</p>
<p id="chart">
<footer>
<p2>Data from the Tate Gallery Github database; sources of code for chart: Mike Bostock and Zan Armstrong</p2>
</footer>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script>
var margin = {top: 30, right: 0, bottom: 20, left: 0},
  width = 960,
  height = 500 - margin.top - margin.bottom,
  formatNumber = d3.format(",%"),
  colorDomain = [-.6, 0, .6],
  colorRange = ["#373a93", 'white', "#936638"],
  transitioning;

//setting x & y scales to determine size of boxes
var x = d3.scale.linear()
  .domain([0, width])
  .range([0, width]);

var y = d3.scale.linear()
  .domain([0, height])
  .range([0, height]);

//first step in creating color scale
var color = d3.scale.linear()
  .domain(colorDomain)
  .range(colorRange);

//creating treemap 
var treemap = d3.layout.treemap()
  .children(function(d, depth) { return depth ? null : d._children; })
  .sort(function(a, b) { return a.value - b.value; })
  .ratio(height / width * 0.5 * (1 + Math.sqrt(5)))
  .round(false);

var svg = d3.select("#chart").append("svg")
  .attr("width", width + margin.left + margin.right)
  .attr("height", height + margin.bottom + margin.top)
  .style("margin-left", -margin.left + "px")
  .style("margin.right", -margin.right + "px")
  .append("g")
  .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
  .style("shape-rendering", "crispEdges");

var grandparent = svg.append("g")
  .attr("class", "grandparent");

grandparent.append("rect")
  .attr("y", -margin.top)
  .attr("width", width)
  .attr("height", margin.top);

grandparent.append("text")
  .attr("x", 6)
  .attr("y", 6 - margin.top)
  .attr("dy", ".75em");

var legend = d3.select("#legend").append("svg")
  .attr("width", width + margin.left + margin.right)
  .attr("height", 30)
  .attr('class', 'legend')
  .selectAll("g")
    .data([0,1,2,3,4,5,6,7,8,9]) //# points in color scale; want to experiment with this more
    .enter()
    .append('g')

//functions
function initialize(root) {
  root.x = root.y = 0;
  root.dx = width;
  root.dy = height;
  root.depth = 0;
}

//aggregate values for internal nodes
function accumulate(d) {
  return (d._children = d.children)
    //recursion 
    ? d.value = d.children.reduce(function(p, v) {return p + accumulate(v); }, 0)
    : d.value;
}

//computing the treemap layout recursively such that each group of siblings does use the same dimensions
//as the parent cell; a wrapper object is created for the parent node for each group of siblings so that the 
//parent's dimensions are not discarded as we recurse; sets up possibility of zooming
function layout(d) {
  if (d._children) {
  treemap.nodes({_children: d._children});
  d._children.forEach(function(c) {
    c.x = d.x + c.x * d.dx;
    c.y = d.y + c.y * d.dy;
    c.dx *= d.dx;
    c.dy *= d.dy;
    c.parent = d;
  //recursion 
  layout(c);
  });
  }
}

function colorIncrements(d) {
  return (colorDomain[colorDomain.length - 1] - colorDomain[0])/18*d + colorDomain[0];
}

legend.append("rect")
  .attr("x", function(d){return margin.left + d * 40})
  .attr("y", 0)
  .attr("fill", function(d) {return color(colorIncrements(d))})
  .attr('width', '40px')
  .attr('height', '40px')

legend.append("text")
  .text(function(d){return formatNumber(colorIncrements(d))})
  .attr('y', 20)
  .attr('x', function(d){return margin.left + d * 40 + 20});

//determines whether white or black will be better contrasting color
function getContrast50(hexcolor) {
  return (parseInt(hexcolor.replace('#', ''), 16) > 0xffffff/3) ? 'black':'white';
}

d3.json("data.json", function(root) {
  console.log(root)
  initialize(root);
  accumulate(root);
  layout(root);
  display(root);

function display(d) {
  grandparent
  .datum(d.parent)
  .on("click", transition)
  .select("text")
  .text(name(d))

   //color header based on grandparent's rate
   grandparent
   .datum(d.parent)
   .select("rect")
   .attr("fill", function(){console.log(color(d.rate)); return color(d['rate'])})

var g1 = svg.insert("g", ".grandparent")
  .datum(d)
  .attr("class", "depth");

var g = g1.selectAll("g")
  .data(d._children)
  .enter().append("g");

  g.filter(function(d) { return d._children; })
  .classed("children", true)
  .on("click", transition);

  g.selectAll(".child")
  .data(function(d) { return d._children || [d]; })
  .enter().append("rect")
  .attr("class", "child")
  .call(rect);

  g.append("rect")
  .attr("class", "parent")
  .call(rect)
  .append("title")
  .text(function(d) {console.log(typeof(d.value), d.value); return d.name + ', Cases of TB: ' + d.value + ', percent change: ' + formatNumber(d.rate); });

  g.append("text")
  .attr("dy", ".75em")
  .text(function(d) { return d.name; })
  .call(text);

function transition(d) {
  if (transitioning || !d) return;
  transitioning = true;

var g2 = display(d),
         t1 = g1.transition().duration(750),
         t2 = g2.transition().duration(750);

//updating the domain after entering new elements 
x.domain([d.x, d.x + d.dx]);
y.domain([d.y, d.y + d.dy]);

//enabling anti-aliasing during the transition 
svg.style("shape-rendering", null);

//drawing child nodes on top of parent nodes 
svg.selectAll(".depth").sort(function(a, b) { return a.depth - b.depth; });

//fade-in entering text
g2.selectAll("text").style("fill-opacity", 0);

//transition to new view 
t1.selectAll("text").call(text).style("fill-opacity", 0);
t2.selectAll("text").call(text).style("fill-opacity", 1);
t1.selectAll("rect").call(rect);
t2.selectAll("rect").call(rect);

//removing old node when transition is finished 
t1.remove().each("end", function() {
  svg.style("shape-rendering", "crispEdges");
  transitioning = false;
});
}

return g;
}

function text(text) {
  text.attr("x", function(d) { return x(d.x) + 6; })
      .attr("y", function(d) { return y(d.y) + 6; })
      .attr("fill", function (d) {return getContrast50(color(parseFloat(d.rate)))});
}

function rect(rect) {
  rect.attr("x", function(d) { return x(d.x); })
      .attr("y", function(d) { return y(d.y); })
      .attr("width", function(d) { return x(d.x + d.dx) - x(d.x); })
      .attr("height", function(d) { return y(d.y + d.dy) - y(d.y); })
      .attr("fill", function(d){return color(parseFloat(d.rate));});
}

function name(d) {
  return d.parent
    ? name(d.parent) + "." + d.name
    : d.name;
}

});
</script>